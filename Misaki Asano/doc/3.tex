%第3章：暗号化手法

本章では,SAS-L2に基づいたデータ通信の暗号化について説明する.
%3章1節
\section{SAS-L2に基づいたデータ通信の暗号化}
本研究では,SAS-L2ワンタイムパスワード認証方式に基づいたセンシングデータ通信の暗号化方法を提案し,
IoTシステムにおいてセンシングデータの暗号化通信を実現させる.
暗号化通信における送信側のセンシングデータの暗号化と
受信側のセンシングデータの復号化のアルゴリズムを説明する.

\subsection{送信側のセンシングデータ暗号化}
アルゴリズム1は,センシングデータを送信するエッジデバイス側の暗号化アルゴリズムである.
$n$回目とは,その時点までに行った提案手法による暗号化通信の回数とする.
以降,エッジデバイスはユーザーと定義する.

ユーザーは初めに,アルゴリズム1の処理1のようにセンシングデータ($SD$)と認証情報$A_{n+1}$,$A_n$の排他的論理和を演算し$\gamma$を生成する.
処理2では,$\gamma$をサーバーに送信する.
処理3では,$\alpha$をサーバーから受信する.
処理4では,$\alpha$と認証情報$A_{n+1}$と秘匿情報$M_{n+1}$の排他的論理和を演算し,$A_{n+2}$の復号化を行う.
処理5では,認証情報$A_{n+1}$と秘匿情報$M_{n+1}$の算術加算により,秘匿情報$M_{n+2}$を生成する.
処理6では,認証情報$A_n$,$A_{n+1}$と秘匿情報$M_{n+1}$を更新する.
処理1から処理6までを1回のエッジデバイス側でのデータ暗号化とし,10回の繰り返しを終えたら,処理7で認証情報$A_n \leftarrow A_{n+1}$,秘匿情報$M_n \leftarrow M_{n+1}$として保存する.
\begin{algorithm}[H]
\caption{$n$回目のエッジデバイス側でのデータ暗号化}
\begin{algorithmic}[1]
\renewcommand{\algorithmicrequire}{\textbf{Input:}}
\renewcommand{\algorithmicensure}{\textbf{Output:}}
\REQUIRE $\alpha$,$SD$,$n$回目認証情報$A_n$,$n+1$回目認証情報$A_{n+1}$,$n+1$回目秘匿情報$M_{n+1}$
\ENSURE $\gamma$
\STATE $\gamma \leftarrow SD \oplus A_{n+1} \oplus A_n$
\STATE $\gamma$をサーバーに送信
\STATE $\alpha$をサーバーから受信
\STATE $A_{n+2} \leftarrow \alpha \oplus A_{n+1} \oplus M_{n+1}$
\STATE $M_{n+2} \leftarrow A_{n+1} + M_{n+1}$
\STATE 認証情報$A_n$,$A_{n+1}$と秘匿情報$M_{n+1}$を更新.
\\ $A_n \leftarrow A_{n+1}$
\\ $A_{n+1} \leftarrow A_{n+2}$
\\ $M_{n+1} \leftarrow M_{n+2}$
\STATE 処理1から6まで10回繰り返した後,認証情報$A_n \leftarrow A_{n+1}$,秘匿情報$M_n \leftarrow M_{n+1}$として保存.
\end{algorithmic} 
\end{algorithm}


\subsection{受信側のセンシングデータの復号化}

アルゴリズム2は,センシングデータを受信するサーバー側の復号のアルゴリズムである.
$n$回目とは,その時点までに行った提案手法による暗号化通信の回数とする.
以降,エッジデバイスはユーザーと定義する.


サーバーは初めに,アルゴリズム2の処理1のように送信者であるユーザーから,センシングデータ($SD$)を暗号化した$\gamma$を受信する.
処理2では,$\gamma$と認証情報$A_{n+1}$,$A_n$の排他的論理和を演算し,$SD$を復号化する.
処理3では,乱数$N_{n+2}$を生成し,
処理4で乱数$N_{n+2}$とユーザー識別子$S$の排他的論理和にハッシュ関数を適用することで,次回認証情報$A_{n+2}$を生成する.
処理5では,認証情報$A_{n+2}$,$A_{n+1}$と秘匿情報$M_{n+1}$の排他的論理和を演算し,$\alpha$を生成する.
処理6では,$\alpha$をユーザーに送信する.
処理7では,認証情報$A_{n+1}$と秘匿情報$M_{n+1}$の算術加算により,秘匿情報$M_{n+2}$を生成する.
処理8では,認証情報$A_n$,$A_{n+1}$と秘匿情報$M_{n+1}$を更新する.
処理1から処理8までを1回のサーバーの暗号化データの復号とし,10回の繰り返しを終えたら,処理9で認証情報$A_n \leftarrow A_{n+1}$,秘匿情報$M_n \leftarrow M_{n+1}$として保存する.
\begin{algorithm}[H]
\caption{n回目のサーバーの暗号化データの復号}
\begin{algorithmic}[1]
\renewcommand{\algorithmicrequire}{\textbf{Input:}}
\renewcommand{\algorithmicensure}{\textbf{Output:}}
\REQUIRE $\gamma$,ユーザー識別子$S$,$n$回目認証情報$A_n$,$n+1$認証情報$A_{n+1}$,$n+1$秘匿情報$M_{n+1}$
\ENSURE $\alpha$,$SD$
\STATE $\gamma$をユーザーから受信
\STATE $SD \leftarrow \gamma \oplus A_{n+1} \oplus A_n$
\STATE 乱数$N_{n+2}$を生成
\STATE $A_{n+2} \leftarrow H(S \oplus N_{n+2})$
\STATE $\alpha \leftarrow A_{n+2} \oplus A_{n+1} \oplus M_{n+1}$
\STATE $\alpha$をユーザーに送信
\STATE $M_{n+2} \leftarrow A_{n+1} + M_{n+1}$
\STATE 認証情報$A_n$,$A_{n+1}$と秘匿情報$M_{n+1}$を更新.
\\ $A_n \leftarrow A_{n+1}$
\\ $A_{n+1} \leftarrow A_{n+2}$
\\ $M_{n+1} \leftarrow M_{n+2}$
\STATE 処理1から8まで10回繰り返した後,認証情報$A_n \leftarrow A_{n+1}$,秘匿情報$M_n \leftarrow M_{n+1}$として保存.
\end{algorithmic} 
\end{algorithm}


\subsection{提案手法の利点}
 第2章で述べたように,従来暗号方式としてバーナム暗号がある.
 バーナム暗号では,鍵は一度しか使用することができず,暗号化を行う度に鍵を共有する必要があり,
 鍵を共有する毎に鍵が直接ネットワークに流れるという欠点がある.
 これに対して,提案手法のSAS-L2に基いたデータ通信の暗号化方法では,鍵を共有する際に,鍵が直接ネットワークに流れないという利点がある.
 例えば,1回目の暗号化通信では,鍵として認証情報$A_2$と認証情報$A_1$が必要となる.
 認証情報$A_1$は,IoTエッジデバイスに初期認証情報として秘匿情報$M_1$と共に書き込まれているとすれば,
 認証者が被認証者に認証情報を送信する必要がなくなる.
 認証情報$A_2$は,認証者が被認証者に送信することで共有するが,
 認証情報$A_1$と秘匿情報$M_1$を持っていなければ認証情報$A_2$を復号することができない.
 このように,提案手法では鍵と認証情報と秘匿情報の排他的論理和を演算して送信することから,鍵がそのままネットワークに流れることなく鍵を配送できる.


また,第2章で述べた従来の暗号化方式であるAESは,暗号化したいデータを,ブロックに分け,ブロック毎に4種類の変換を複数回繰り返すことで暗号化が行われる.このように,AESなどの従来の暗号化方式は暗号化での処理負荷が大きい.これに対して,提案手法では暗号化を行いたいデータと認証情報$A_n$と$A_{n+1}$との排他的論理和を演算し,第3章で説明したSAS-L2の認証アルゴリズムと同様に鍵を更新することで暗号化通信ができる.このように,従来の暗号化方式と比較して提案手法は処理負荷が小さく,処理性能の低いIoTセンシングデバイスへの実装が実現できる.
